# 第十四章 内部类

+ jdk1.8之后出了一个lambda表达式--对实现类的简化

> 问：什么是内部类？
>
> 答：声明在一个类的内部，称为内部类
>
> * 包含内部类的类称为外围类
> * 不包含内部类的类称为顶级类


- 历史：
- 背景：把关系密切的类声明在内部
- 作用：简化实现类


***

### 内部类分类：
1. 静态成员类
2. 实例成员类
3. 局部内部类
4. 匿名类




### 规则：
1. 静态成员类

 * 【定义】 结构上就类似于静态成员变量一样。跟（外围）类紧密相连，跟外围类的对象没什么关系，可以脱离外围类的对象使用。
 * 【位置】 在外围类的内部，声明的时候，static声明一个 类即可
 * 【语法】【访问权限修饰符（任意），习惯上写成public】【访问权限修饰符】static class 内部类的名字{  类体   }

    1. 在外围类内部方法内，可以通过"内部类名.静态成员名"的方式访问(Inner.y();)
    2. 在外围类外部，可以通过"外围类名.静态成员类.对象"(Outer.Inner.y();)
    3. 在静态成员类中，可以访问到外围类的静态成员，但是不能访问到外围类的实例成员。
    为什么？静态成员类跟外围类相关，跟外围的对象无关。当调取外围类的实例成员时，实例很可能还没有。



2. 实例成员类

 * 【定义】 跟成员变量  地位类似，跟外围类的对象紧密相关，但是跟外围类无关。
 * 【位置】外围类的内部
 * 【语法】【访问权限修饰符】  class 内部类名字{ 类体  }
   
   1. 实例成员类：在外围类的内部，可以直接访问
                 在外围类的外部，必须通过外围类的对象才能访问。
                 访问的形式：外围对象.new 内部类的名字:Outer.Inner  i = o.new Inner();
   2. 在实例成员类中， 访问外部成员任意静态与非静态
                   （原因：实例成员类非静态的，在非静态的环境下可以访问静态和静态）
     当实例成员类的对象产生的时候，外围类的对象一定产生了。
    【特殊的情况】 static  +final 也可以访问到。
    
   3. 实例成员类中，不能够声明任何的静态成员、静态初始化块。
      为什么  假如可以  Outer.Inner.k  ，Inner本身就需要Outer对象产生。没有Outer对象，实例成员类的内部内容什么都不可能访问到。
      【特殊】 使用static final定义常量可以定义在实例内部类中。（为什么？）跟所有对象都没关系，甚至于跟类都没什么关系
       在编译期，甚至于在字节码文件中根本不存在final类型变量名。常量的存储只要存储在静态区，访问的时候，直接访问存储的地址。
      【关于静态存储（了解）】
      
   4. 实例成员内部类会遮蔽外围类的同名成员变量。
     相当于：成员变量
     局部变量会遮蔽成员变量，内部类的成员变量也会遮蔽外围的成员变量


3. 局部内部类

  * 【定义】声明在类内部，同时声明在局部范围内（方法、语句块）里面声明的类，被称为是本地类（局部类）
  * 【定义语法】 在方法中，语句块中【访问权限修饰符（没有）】【修饰符static（没有）】class 内部类名字{  类体 }
  * 【作用域】 同局部变量，从声明的位置到最小的语句块
  * 【规则】
    1. 不能使用访问权限修饰符和static修饰符
    2. 局部类 内部 不能声明静态成员（同实体类）
       (因为没有外部类的对象，所以不能访问到静态成员。Inner要依靠外部类的对象产生。)
    3. * 非静态方法中---创建局部类----在局部类中创建非静态方法，
                         访问外围类的成员限制：无理论是访问静态成员还是非静态成员都可以。
       * 静态方法中----创建局部类----在局部类中非静态方法，
                         访问外围类的成员限制：可以访问静态成员，但是不能访问非静态成员（实例成员）
                        为什么？静态方法中只能访问静态的内容
    4. 常见应用：在外围类的外面声明一个接口，在外围类的方法中，声明一个局部类，这个局部类实现实现外部的接口。
                在实现中返回局部类的对象（接口对应）
                这样的局部类对象就可以在作用域外有效





* 简单局部类的调用
```java
// 定义一个外围类
class Outer  {
    public void fun(){
        class Inner{
            public void f1(){
                System.out.println("1111111111我是局部类");
            }
        }
        // 创建局部类对象，调用对象.方法
        Inner i = new Inner();
        i.f1();
    }
}

public class Day09 {
    public static void main(String[] args) {

        // 调用
        // 创建一个Outer类的对象
        Outer o = new Outer();
        o.fun();

    }
}
```

继承接口的引用方式
```java
interface Mobile {
    // 在接口内声明一个方法
    void call();
}

// 定义一个外围类
class Outer {
    public void fun() {
        class Inner implements Mobile {
            @Override
            public void call() {
                System.out.println("wwwwww 我继承了mobile接口");
            }
        }
        // 父类引用 指向 子类对象
        Mobile mobile = new Inner();
        // 父类调用子类call方法
        mobile.call();
    }
}

public class Day09 {
    public static void main(String[] args) {

        // 创建一个Outer类的对象
        Outer o = new Outer();
        o.fun();

    }
}
```

```java

interface Mobile {
    // 在接口内声明一个方法
    void call();
}

// 定义一个外围类
class Outer {
    public Mobile fun() {
        class Inner implements Mobile {
            @Override
            public void call() {
                System.out.println("wwwwww 我继承了mobile接口");
            }
        }
        // 父类引用 指向 子类对象
        Mobile mobile = new Inner();
        // 父类调用子类call方法
       // mobile.call();
        return mobile;
    }

}

public class Day09 {
    public static void main(String[] args) {

        // 创建一个Outer类的对象
        Outer o = new Outer();
        Mobile m = o.fun();
        m.call();


    }
}
```













4. 匿名类

* 只使用一次




5. lambda表达式

* 作用：实现接口中一个方法（甚至连实现都不需要实现）
可以代表一个普通的实现类


* 【语法】： ()->{}
            (参数)->{类体}

### 定义：

```java
// 代码段

```




### 方法引用

* 如有已有的方法实现了相关内容，我们可以直接使用方法的引用，来调用实现的内容

1. 引用静态方法（重要）
2. 通过对象引用实例方法
3. 通过类引用实例方法
4. 引用构造器



* 解释
1. 引用静态方法（重要）

【定义】通过已有的静态方法来实现，实现类

【语法】类名：：方法名

不需要传入参数：1.引用参数，2.实际参数
因为函数式接口，只有一个未实现的方法，
形参直接使用函数式接口的形参，实际直接使用前面的形式参数依次赋值



2. 通过对象引用实例方法

要有实现类的对象，才可以调用到方法
语法：对象名::方法名

3. 通过类引用实例方法
在实例类下实现一个方法
语法：实例类::方法名

形参依然是接口中的参数
实际参数，会将接口的第一个参数作为对象，第二个参数作为实际参数






























