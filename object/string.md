# 第十六章 String类

* 特殊的引用类型

## 一、常量池机制

字符串类型也是不可变类型，
对于编译期确定的字符串常量放进内存上一块空间，称为常量池



## 二、从说创建

1. 【=】 使用等号，创建字符串，一定先检查=右侧的字符串是否在常量中是否已存在，用equals方法判断
         = 右侧的数据必须是编译期就可以确定的才加入到字符串常量池
         
2. 【new】new一个对象，就会像堆中申请一小片空间
      * String s = new String("abc");
      1. 先到字符串常量池中检测，是否已存在，如果不存在，则创建
      2. new一个字符串就会在堆中创建一个字符串，将常量池的字符串对象复制过来放到堆中。
      
      如果常量池中没有，则会在常量池创建一个，在堆中创建一个。
      

* string字符串的底层是使用char[]数组的形式进行存储的。


3. 细说字符串创建

* String s = new String("abc");

字符串常量池
1. 当在编译期能够确定的字符串常量，会在编译期

* 介绍字符串对象下的intern方法
作用：到常量池检查是否存在某个字符串，如果存在就返回常量池中的对象，如果不存在就创建一个字符串，返回常量池中的字符串


常量+常量 = 放常量池
常量 + 变量 = 不放常量池

## 三、字符串相关方法

- compareTo 作用：判断字符串的大小,

1. 当前字符串大于value对象，返回 >0
2. 当前字符串等于value对象，返回 0
3. 当前字符串小于value对象，返回 <0

* 一个类实现了comparable接口的compareTo方法，就可以是用Array.sort方法进行排序
* 也可以在sort方法中，创建comparator的实现类



类中实现接口Comparable, 调用compareTo方法： 
    如果 返回值大于0，则将大的数放后面；
    如果返回值等于0，则不做任何处理; 
    如果返回值小于0， 则将小的数放前面。也就是说 java默认的排序方式是升序排序

### comparable 是一个接口，
### 












## 四、StringBuffer和StringBuilder

* 关系，亲兄弟，用来存储字符串。

1. String
    1. jdk 1.0 就有了
    2. 不可变对象，好处，多线程的时候，可以避免数据共享，可以达到线程安全
    3. 不可变对象，坏处，如需持续多个字符串，会创建更多的字符串，占用更多的内存
    4. 不支持对单个字符的增删改查
    5. 线程安全的
    
2. StringBuffer
    1. jdk 1.4 增加的（用来解决string效率问题）
    2. 可变字符串---字符串缓冲区 
    3. 从来不会把字符串创建到常量池，直接存放到堆中
    4. 使用new 关键字创建字符串，只在堆中创建一个对象
    5. 下面的方法都是原地操作，因为他是可变字符串，支持对单个字符的增删改查
    6. 线程安全的
  
3. StringBuilder
    1. jdk 1.5 增加的 （用来解决stringbuffer效率问题）
    2. 可变字符串
    3. 线程不安全的，性能高
    4. 原地操作，支持对单个字符的增删改查





> 什么是不可变数据？
> 
> 就是定义一个对象，不能修改，如果修改了，就会在产生一个对象


        long start = System.nanoTime();
        System.out.println(s1);
        long end = System.nanoTime();
        System.out.println(end-start);


